## å‰è¨€

ç²¾è¯»ç³»åˆ—ï¼Œæ—¨åœ¨åˆ†æä¸€äº›é«˜è´¨é‡ä»£ç åº“ï¼Œå­¦ä¹ å€Ÿé‰´å…¶ä¸­çš„æ€æƒ³ï¼Œå·©å›ºjsåŸºç¡€ã€‚

æœ¬æ–‡å¼€å§‹å¯¹lodashä¸­çš„cloneDeepæ–¹æ³•ç²¾è¯»ã€‚

## æ•´ç†æºç 

é¦–å…ˆæŠŠlodashä¸­cloneDeepç›¸å…³ä»£ç æ•´ç†å‡ºæ¥

![01.png](./assets/08/01.png)

![02.png](./assets/08/02.png)

42ä¸ªæ–‡ä»¶ï¼ŒğŸ˜­ğŸ˜­ğŸ˜­ã€‚

## å¼€å§‹åˆ†æ

é¦–å…ˆçœ‹å…¥å£æ–‡ä»¶

```javascript
import baseClone from './baseClone.js'

/** Used to compose bitmasks for cloning. */
const CLONE_DEEP_FLAG = 1
const CLONE_SYMBOLS_FLAG = 4

/**
 * This method is like `clone` except that it recursively clones `value`.
 * Object inheritance is preserved.
 *
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see clone
 * @example
 *
 * const objects = [{ 'a': 1 }, { 'b': 2 }]
 *
 * const deep = cloneDeep(objects)
 * console.log(deep[0] === objects[0])
 * // => false
 */
function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
}

export default cloneDeep
```

baseCloneæ–¹æ³•ç¬¬äºŒä¸ªå‚æ•°`CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG`ï¼Œè¿™ä¸ªå‚æ•°æ˜¾ç„¶æ˜¯æ§åˆ¶baseCloneé‡‡ç”¨å“ªç§å…‹éš†æ–¹å¼çš„ï¼Œä½†æ˜¯ä¸ºå•¥ä¼šç”¨ä½è¿ç®—å‘¢ï¼Œæœ‰ç‚¹æ‡µé€¼ã€‚

ä¸€ç•ªç™¾åº¦ä¹‹åï¼Œå¼„æ˜ç™½äº†ã€‚

ç»“åˆbaseCloneåˆ†æã€‚

```javascript
/** Used to compose bitmasks for cloning. */
const CLONE_DEEP_FLAG = 1
const CLONE_FLAT_FLAG = 2
const CLONE_SYMBOLS_FLAG = 4

function baseClone(value, bitmask, customizer, key, object, stack) {
    let result
    const isDeep = bitmask & CLONE_DEEP_FLAG
    const isFlat = bitmask & CLONE_FLAT_FLAG
    const isFull = bitmask & CLONE_SYMBOLS_FLAG

    if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value)
    }
    if (result !== undefined) {
        return result
    }
    if (!isObject(value)) {
        return value
    }
    const isArr = Array.isArray(value)
    const tag = getTag(value)
    if (isArr) {
        result = initCloneArray(value)
        if (!isDeep) {
            return copyArray(value, result)
        }
    } else {
        const isFunc = typeof value == 'function'

        if (isBuffer(value)) {
            return cloneBuffer(value, isDeep)
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
            result = (isFlat || isFunc) ? {} : initCloneObject(value)
            if (!isDeep) {
                return isFlat
                    ? copySymbolsIn(value, copyObject(value, keysIn(value), result))
                    : copySymbols(value, Object.assign(result, value))
            }
        } else {
            if (isFunc || !cloneableTags[tag]) {
                return object ? value : {}
            }
            result = initCloneByTag(value, tag, isDeep)
        }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack)
    const stacked = stack.get(value)
    if (stacked) {
        return stacked
    }
    stack.set(value, result)

    if (tag == mapTag) {
        value.forEach((subValue, key) => {
            result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))
        })
        return result
    }

    if (tag == setTag) {
        value.forEach((subValue) => {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))
        })
        return result
    }

    if (isTypedArray(value)) {
        return result
    }

    const keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys)

    const props = isArr ? undefined : keysFunc(value)
    arrayEach(props || value, (subValue, key) => {
        if (props) {
            key = subValue
            subValue = value[key]
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))
    })
    return result
}
```

`bitmask & CLONE_DEEP_FLAG`è¡¨ç¤ºä½æ©ç å‚æ•°æ˜¯å¦æ‹¥æœ‰`CLONE_DEEP_FLAG`ï¼Œè€Œ`CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG`è¡¨ç¤ºä¸¤ä¸ªflagéƒ½æ‹¥æœ‰ã€‚æœ¬è´¨ä¸Šæ˜¯ä¸‹é¢è¿™æ ·çš„è¿‡ç¨‹

```javascript
const bitmask=1|4 
// 1.è½¬åŒ–ä¸ºäºŒè¿›åˆ¶ï¼š001|100->101
// 2.è½¬åŒ–ä¸ºåè¿›åˆ¶ï¼š101->5
bitmask & 1 //-> 5&1
// 1.è½¬åŒ–ä¸ºäºŒè¿›åˆ¶ï¼š101&001->001
// 2.è½¬åŒ–ä¸ºå¸ƒå°”å€¼ï¼š001->1-> true
bitmask & 2 //-> 5&2 ->0-> false
bitmask & 4 //-> 5&4 ->4-> true
```

è‡³äºä¸ºä»€ä¹ˆè¦é‡‡å–ä½è¿ç®—ï¼Œå› ä¸ºå¿«ã€‚å¯¹äºè¿™æ ·çš„åŸºç¡€åº“ï¼Œä½œè€…ç”¨ç‰ºç‰²è¯­ä¹‰æ˜ç¡®æ¢å–æ€§èƒ½æ˜¯å¾ˆæ˜æ™ºçš„é€‰æ‹©ã€‚

æ¥ç€å¾€ä¸‹åˆ†æ

#### åˆ¤æ–­æ˜¯å¦ä¸ºå¯¹è±¡

```javascript
if (!isObject(value)) {
    return value
}

function isObject(value) {
  const type = typeof value
  return value != null && (type == 'object' || type == 'function')
}
```

`value!=null`æ’é™¤äº†nullä¸undefinedï¼Œé‚£ä¹ˆä¸æ˜¯objectä¸functionçš„å°±å¯ä»¥è®¤ä¸ºæ˜¯è¿™äº›**Number,String,Boolean,Symbol**ï¼Œè¿™äº›ç±»å‹ï¼ˆnull,undefinedä¹Ÿä¿å­˜åœ¨æ ˆä¸­ï¼‰æ˜¯ç›´æ¥ä¿å­˜åœ¨æ ˆä¸­ï¼Œç›´æ¥è¿”å›å³å¯ã€‚

#### å¯¹å€¼è¿›è¡ŒtoString

```javascript
function getTag(value) {
  if (value == null) {
    return value === undefined ? '[object Undefined]' : '[object Null]'
  }
  return toString.call(value)
}
```

nullä¸undefinedæ˜¯æ²¡æœ‰toStringæ–¹æ³•çš„ï¼Œæ‰€ä»¥åšäº†èŒƒå¼å¤„ç†ã€‚

#### cloneæ•°ç»„

```javascript
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
    const { length } = array
    const result = new array.constructor(length)

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index
        result.input = array.input
    }
    return result
}
```

è¿™ä¸ªæ–¹æ³•æ˜¯è¿”å›ä¸€ä¸ªå’Œç»™å®šæ•°ç»„é•¿åº¦ç›¸åŒçš„ç¨€æ¾æ•°ç»„ï¼Œ`length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')`è¿™ä¸ªåˆ¤æ–­å…¶å®æ˜¯é’ˆå¯¹çš„æ˜¯execæ–¹æ³•è¿”å›çš„ç‰¹å®šæ•°ç»„ï¼Œmdnä¸Šæœ‰è¿™æ ·ä¸€ä¸ªä¾‹å­

```js
var re = /quick\s(brown).+?(jumps)/ig;
var result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog');

// result
// ["Quick Brown Fox Jumps", "Brown", "Jumps", index: 4, input: "The Quick Brown Fox Jumps Over The Lazy Dog", groups: undefined]
```

## æ€»ç»“

æœ¬ç¯‡åšäº†å…³äºcloneDeepçš„ç²¾è¯»å¼€ç¯‡ï¼Œæ¥ä¸‹æ¥å°†æ·±å…¥äº†è§£å…¶å¯¹å¤æ‚æ•°æ®ç±»å‹çš„åˆ¤æ–­ä¸cloneå¤„ç†ã€‚